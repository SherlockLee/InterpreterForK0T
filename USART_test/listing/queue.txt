; generated by ARM C/C++ Compiler, 4.1 [Build 644]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\queue.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\obj\queue.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\library\inc -I..\..\library\src -I..\uvsion -If:\Keil\ARM\CMSIS\Include -If:\Keil\ARM\INC\ST\STM32F10x -D__MICROLIB --omf_browse=.\obj\queue.crf Queue.c]
                          THUMB

                          AREA ||i.CopyToItem||, CODE, READONLY, ALIGN=1

                  CopyToItem PROC
;;;146    
;;;147    static void CopyToItem(Node *pn,Item *pi)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;148    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;149    	int i=0,j=0;
000008  f04f0000          MOV      r0,#0
00000c  4607              MOV      r7,r0
00000e  4606              MOV      r6,r0
;;;150    #ifdef AA
;;;151    	(*pi).a_flag=(pn->item).a_flag;
;;;152    	(*pi).a_number=(pn->item).a_number;
;;;153    #endif
;;;154    
;;;155    #ifdef BB
;;;156    	(*pi).b_flag=(pn->item).b_flag;
;;;157    	(*pi).b_number=(pn->item).b_number;
;;;158    #endif
;;;159    
;;;160    #ifdef CC
;;;161    	(*pi).c_flag=(pn->item).c_flag;
;;;162    	(*pi).c_number=(pn->item).c_number;
;;;163    #endif
;;;164    	strcpy((*pi).comment,(pn->item).comment);
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       strcpy
;;;165    	(*pi).d_number=(pn->item).d_number;
000018  f8d40100          LDR      r0,[r4,#0x100]
00001c  f8c50100          STR      r0,[r5,#0x100]
;;;166    	(*pi).f_number=(pn->item).f_number;
000020  f5047084          ADD      r0,r4,#0x108
000024  c803              LDM      r0,{r0,r1}
000026  f5057284          ADD      r2,r5,#0x108
00002a  c203              STM      r2!,{r0,r1}
;;;167    	for(;i<14;i++)
00002c  e00a              B        |L1.68|
                  |L1.46|
;;;168    	{
;;;169    		(*pi).g_modes[i]=(pn->item).g_modes[i];
00002e  f5047088          ADD      r0,r4,#0x110
000032  f8501027          LDR      r1,[r0,r7,LSL #2]
000036  f5057088          ADD      r0,r5,#0x110
00003a  f8401027          STR      r1,[r0,r7,LSL #2]
00003e  f1070001          ADD      r0,r7,#1              ;167
000042  4607              MOV      r7,r0                 ;167
                  |L1.68|
000044  2f0e              CMP      r7,#0xe               ;167
000046  dbf2              BLT      |L1.46|
;;;170    	}
;;;171    	(*pi).h_number=(pn->item).h_number;
000048  f50474a4          ADD      r4,r4,#0x148
00004c  f50575a4          ADD      r5,r5,#0x148
000050  6820              LDR      r0,[r4,#0]
000052  6028              STR      r0,[r5,#0]
;;;172    	(*pi).i_flag=(pn->item).i_flag;
000054  6860              LDR      r0,[r4,#4]
000056  6068              STR      r0,[r5,#4]
;;;173    	(*pi).i_number=(pn->item).i_number;
000058  e9d40102          LDRD     r0,r1,[r4,#8]
00005c  e9c50102          STRD     r0,r1,[r5,#8]
;;;174    	(*pi).j_flag=(pn->item).j_flag;
000060  6920              LDR      r0,[r4,#0x10]
000062  6128              STR      r0,[r5,#0x10]
;;;175    	(*pi).j_number=(pn->item).j_number;
000064  e9d40106          LDRD     r0,r1,[r4,#0x18]
000068  e9c50106          STRD     r0,r1,[r5,#0x18]
;;;176    	(*pi).k_flag=(pn->item).k_flag;
00006c  6a20              LDR      r0,[r4,#0x20]
00006e  6228              STR      r0,[r5,#0x20]
;;;177    	(*pi).k_number=(pn->item).k_number;
000070  e9d4010a          LDRD     r0,r1,[r4,#0x28]
000074  e9c5010a          STRD     r0,r1,[r5,#0x28]
;;;178    	(*pi).l_number=(pn->item).l_number;
000078  6b20              LDR      r0,[r4,#0x30]
00007a  6328              STR      r0,[r5,#0x30]
;;;179    	(*pi).line_number=(pn->item).line_number;
00007c  6b60              LDR      r0,[r4,#0x34]
00007e  6368              STR      r0,[r5,#0x34]
;;;180    	(*pi).motion_to_be=(pn->item).motion_to_be;
000080  6ba0              LDR      r0,[r4,#0x38]
000082  63a8              STR      r0,[r5,#0x38]
;;;181    	(*pi).m_count=(pn->item).m_count;
000084  6be0              LDR      r0,[r4,#0x3c]
000086  f5a474a4          SUB      r4,r4,#0x148
00008a  63e8              STR      r0,[r5,#0x3c]
00008c  f5a575a4          SUB      r5,r5,#0x148
;;;182    	for(;j<10;j++)
000090  e00a              B        |L1.168|
                  |L1.146|
;;;183    	{
;;;184    		(*pi).m_modes[j]=(pn->item).m_modes[j];
000092  f50470c4          ADD      r0,r4,#0x188
000096  f8501026          LDR      r1,[r0,r6,LSL #2]
00009a  f50570c4          ADD      r0,r5,#0x188
00009e  f8401026          STR      r1,[r0,r6,LSL #2]
0000a2  f1060001          ADD      r0,r6,#1              ;182
0000a6  4606              MOV      r6,r0                 ;182
                  |L1.168|
0000a8  2e0a              CMP      r6,#0xa               ;182
0000aa  dbf2              BLT      |L1.146|
;;;185    	}
;;;186    	(*pi).p_number=(pn->item).p_number;
0000ac  f50474d8          ADD      r4,r4,#0x1b0
0000b0  f50575d8          ADD      r5,r5,#0x1b0
0000b4  e9d41000          LDRD     r1,r0,[r4,#0]
0000b8  e9c51000          STRD     r1,r0,[r5,#0]
;;;187    	(*pi).q_number=(pn->item).q_number;
0000bc  e9d40102          LDRD     r0,r1,[r4,#8]
0000c0  e9c50102          STRD     r0,r1,[r5,#8]
;;;188    	(*pi).r_flag=(pn->item).r_flag;
0000c4  6920              LDR      r0,[r4,#0x10]
0000c6  6128              STR      r0,[r5,#0x10]
;;;189    	(*pi).r_number=(pn->item).r_number;
0000c8  e9d40106          LDRD     r0,r1,[r4,#0x18]
0000cc  e9c50106          STRD     r0,r1,[r5,#0x18]
;;;190    	(*pi).s_number=(pn->item).s_number;
0000d0  e9d40108          LDRD     r0,r1,[r4,#0x20]
0000d4  e9c50108          STRD     r0,r1,[r5,#0x20]
;;;191    	(*pi).t_number=(pn->item).t_number;
0000d8  6aa0              LDR      r0,[r4,#0x28]
0000da  62a8              STR      r0,[r5,#0x28]
;;;192    	(*pi).x_flag=(pn->item).x_flag;
0000dc  6ae0              LDR      r0,[r4,#0x2c]
0000de  62e8              STR      r0,[r5,#0x2c]
;;;193    	(*pi).x_number=(pn->item).x_number;
0000e0  e9d4010c          LDRD     r0,r1,[r4,#0x30]
0000e4  e9c5010c          STRD     r0,r1,[r5,#0x30]
;;;194    	(*pi).y_flag=(pn->item).y_flag;
0000e8  6ba0              LDR      r0,[r4,#0x38]
0000ea  63a8              STR      r0,[r5,#0x38]
;;;195    	(*pi).y_number=(pn->item).y_number;
0000ec  e9d40110          LDRD     r0,r1,[r4,#0x40]
0000f0  e9c50110          STRD     r0,r1,[r5,#0x40]
;;;196    	(*pi).z_flag=(pn->item).z_flag;
0000f4  6ca0              LDR      r0,[r4,#0x48]
0000f6  64a8              STR      r0,[r5,#0x48]
;;;197    	(*pi).z_number=(pn->item).z_number;
0000f8  e9d41014          LDRD     r1,r0,[r4,#0x50]
0000fc  f5a474d8          SUB      r4,r4,#0x1b0
000100  e9c51014          STRD     r1,r0,[r5,#0x50]
000104  f5a575d8          SUB      r5,r5,#0x1b0
;;;198    }
000108  e8bd81f0          POP      {r4-r8,pc}
                          ENDP


                          AREA ||i.CopyToNode||, CODE, READONLY, ALIGN=1

                  CopyToNode PROC
;;;91     
;;;92     static void CopyToNode(Item item,Node *pn)
000000  b40f              PUSH     {r0-r3}
;;;93     {
000002  b570              PUSH     {r4-r6,lr}
000004  9c86              LDR      r4,[sp,#0x218]
;;;94     	/*结构体拷贝之――直接赋值法*/
;;;95     	int i=0,j=0;
000006  f04f0000          MOV      r0,#0
00000a  4605              MOV      r5,r0
00000c  4606              MOV      r6,r0
;;;96     #ifdef AA
;;;97     	(pn->item).a_flag=item.a_flag;
;;;98     	(pn->item).a_number=item.a_number;
;;;99     #endif
;;;100    
;;;101    #ifdef BB
;;;102    	(pn->item).b_flag=item.b_flag;
;;;103    	(pn->item).b_number=item.b_number;
;;;104    #endif
;;;105    
;;;106    #ifdef CC
;;;107    	(pn->item).c_flag=item.c_flag;
;;;108    	(pn->item).c_number=item.c_number;
;;;109    #endif
;;;110    	strcpy((pn->item).comment,item.comment);
00000e  a904              ADD      r1,sp,#0x10
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       strcpy
;;;111    	(pn->item).d_number=item.d_number;
000016  9844              LDR      r0,[sp,#0x110]
000018  f8c40100          STR      r0,[r4,#0x100]
;;;112    	(pn->item).f_number=item.f_number;
00001c  9947              LDR      r1,[sp,#0x11c]
00001e  9846              LDR      r0,[sp,#0x118]
000020  f5047284          ADD      r2,r4,#0x108
000024  c203              STM      r2!,{r0,r1}
;;;113    	for(;i<14;i++)
000026  e009              B        |L2.60|
                  |L2.40|
;;;114    	{
;;;115    		(pn->item).g_modes[i]=item.g_modes[i];
000028  a848              ADD      r0,sp,#0x120
00002a  f8501025          LDR      r1,[r0,r5,LSL #2]
00002e  f5047088          ADD      r0,r4,#0x110
000032  f8401025          STR      r1,[r0,r5,LSL #2]
000036  f1050001          ADD      r0,r5,#1              ;113
00003a  4605              MOV      r5,r0                 ;113
                  |L2.60|
00003c  2d0e              CMP      r5,#0xe               ;113
00003e  dbf3              BLT      |L2.40|
;;;116    	}
;;;117    	(pn->item).h_number=item.h_number;
000040  f50474a4          ADD      r4,r4,#0x148
000044  9856              LDR      r0,[sp,#0x158]
000046  6020              STR      r0,[r4,#0]
;;;118    	(pn->item).i_flag=item.i_flag;
000048  9857              LDR      r0,[sp,#0x15c]
00004a  6060              STR      r0,[r4,#4]
;;;119    	(pn->item).i_number=item.i_number;
00004c  9959              LDR      r1,[sp,#0x164]
00004e  9858              LDR      r0,[sp,#0x160]
000050  e9c40102          STRD     r0,r1,[r4,#8]
;;;120    	(pn->item).j_flag=item.j_flag;
000054  985a              LDR      r0,[sp,#0x168]
000056  6120              STR      r0,[r4,#0x10]
;;;121    	(pn->item).j_number=item.j_number;
000058  995d              LDR      r1,[sp,#0x174]
00005a  985c              LDR      r0,[sp,#0x170]
00005c  e9c40106          STRD     r0,r1,[r4,#0x18]
;;;122    	(pn->item).k_flag=item.k_flag;
000060  985e              LDR      r0,[sp,#0x178]
000062  6220              STR      r0,[r4,#0x20]
;;;123    	(pn->item).k_number=item.k_number;
000064  9961              LDR      r1,[sp,#0x184]
000066  9860              LDR      r0,[sp,#0x180]
000068  e9c4010a          STRD     r0,r1,[r4,#0x28]
;;;124    	(pn->item).l_number=item.l_number;
00006c  9862              LDR      r0,[sp,#0x188]
00006e  6320              STR      r0,[r4,#0x30]
;;;125    	(pn->item).line_number=item.line_number;
000070  9863              LDR      r0,[sp,#0x18c]
000072  6360              STR      r0,[r4,#0x34]
;;;126    	(pn->item).motion_to_be=item.motion_to_be;
000074  9864              LDR      r0,[sp,#0x190]
000076  63a0              STR      r0,[r4,#0x38]
;;;127    	(pn->item).m_count=item.m_count;
000078  9865              LDR      r0,[sp,#0x194]
00007a  63e0              STR      r0,[r4,#0x3c]
00007c  f5a474a4          SUB      r4,r4,#0x148
;;;128    	for(;j<10;j++)
000080  e009              B        |L2.150|
                  |L2.130|
;;;129    	{
;;;130    		(pn->item).m_modes[j]=item.m_modes[j];
000082  a866              ADD      r0,sp,#0x198
000084  f8501026          LDR      r1,[r0,r6,LSL #2]
000088  f50470c4          ADD      r0,r4,#0x188
00008c  f8401026          STR      r1,[r0,r6,LSL #2]
000090  f1060001          ADD      r0,r6,#1              ;128
000094  4606              MOV      r6,r0                 ;128
                  |L2.150|
000096  2e0a              CMP      r6,#0xa               ;128
000098  dbf3              BLT      |L2.130|
;;;131    	}
;;;132    	(pn->item).p_number=item.p_number;
00009a  f50474d8          ADD      r4,r4,#0x1b0
00009e  9971              LDR      r1,[sp,#0x1c4]
0000a0  9870              LDR      r0,[sp,#0x1c0]
0000a2  e9c40100          STRD     r0,r1,[r4,#0]
;;;133    	(pn->item).q_number=item.q_number;
0000a6  9973              LDR      r1,[sp,#0x1cc]
0000a8  9872              LDR      r0,[sp,#0x1c8]
0000aa  e9c40102          STRD     r0,r1,[r4,#8]
;;;134    	(pn->item).r_flag=item.r_flag;
0000ae  9874              LDR      r0,[sp,#0x1d0]
0000b0  6120              STR      r0,[r4,#0x10]
;;;135    	(pn->item).r_number=item.r_number;
0000b2  9977              LDR      r1,[sp,#0x1dc]
0000b4  9876              LDR      r0,[sp,#0x1d8]
0000b6  e9c40106          STRD     r0,r1,[r4,#0x18]
;;;136    	(pn->item).s_number=item.s_number;
0000ba  9979              LDR      r1,[sp,#0x1e4]
0000bc  9878              LDR      r0,[sp,#0x1e0]
0000be  e9c40108          STRD     r0,r1,[r4,#0x20]
;;;137    	(pn->item).t_number=item.t_number;
0000c2  987a              LDR      r0,[sp,#0x1e8]
0000c4  62a0              STR      r0,[r4,#0x28]
;;;138    	(pn->item).x_flag=item.x_flag;
0000c6  987b              LDR      r0,[sp,#0x1ec]
0000c8  62e0              STR      r0,[r4,#0x2c]
;;;139    	(pn->item).x_number=item.x_number;
0000ca  997d              LDR      r1,[sp,#0x1f4]
0000cc  987c              LDR      r0,[sp,#0x1f0]
0000ce  e9c4010c          STRD     r0,r1,[r4,#0x30]
;;;140    	(pn->item).y_flag=item.y_flag;
0000d2  987e              LDR      r0,[sp,#0x1f8]
0000d4  63a0              STR      r0,[r4,#0x38]
;;;141    	(pn->item).y_number=item.y_number;
0000d6  9981              LDR      r1,[sp,#0x204]
0000d8  9880              LDR      r0,[sp,#0x200]
0000da  e9c40110          STRD     r0,r1,[r4,#0x40]
;;;142    	(pn->item).z_flag=item.z_flag;
0000de  9882              LDR      r0,[sp,#0x208]
0000e0  64a0              STR      r0,[r4,#0x48]
;;;143    	(pn->item).z_number=item.z_number;	
0000e2  9985              LDR      r1,[sp,#0x214]
0000e4  9884              LDR      r0,[sp,#0x210]
0000e6  e9c40114          STRD     r0,r1,[r4,#0x50]
0000ea  f5a474d8          SUB      r4,r4,#0x1b0
;;;144    	/*结构体拷贝之――内存复制法*/
;;;145    }
0000ee  bc70              POP      {r4-r6}
0000f0  f85dfb14          LDR      pc,[sp],#0x14
;;;146    
                          ENDP


                          AREA ||i.DeQueue||, CODE, READONLY, ALIGN=1

                  DeQueue PROC
;;;63     
;;;64     bool DeQueue(Item *pitem,Queue *pq)
000000  b570              PUSH     {r4-r6,lr}
;;;65     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;66     	Node *pt;
;;;67     	if (QueueIsEmpty(pq))
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       QueueIsEmpty
00000c  b108              CBZ      r0,|L3.18|
;;;68     	{
;;;69     		return FALSE;
00000e  2000              MOVS     r0,#0
                  |L3.16|
;;;70     	}
;;;71     	CopyToItem(pq->front,pitem);
;;;72     	pt = pq->front;
;;;73     	pq->front = pq->front->next;
;;;74     	free(pt);
;;;75     	pq->items--;
;;;76     	if (pq->items == 0)
;;;77     	{
;;;78     		pq->rear = NULL;
;;;79     	}
;;;80     	return TRUE;
;;;81     }
000010  bd70              POP      {r4-r6,pc}
                  |L3.18|
000012  6821              LDR      r1,[r4,#0]            ;71
000014  4608              MOV      r0,r1                 ;71
000016  4629              MOV      r1,r5                 ;71
000018  f7fffffe          BL       CopyToItem
00001c  6826              LDR      r6,[r4,#0]            ;72
00001e  6820              LDR      r0,[r4,#0]            ;73
000020  f8d00208          LDR      r0,[r0,#0x208]        ;73
000024  6020              STR      r0,[r4,#0]            ;73
000026  4630              MOV      r0,r6                 ;74
000028  f7fffffe          BL       free
00002c  68a0              LDR      r0,[r4,#8]            ;75
00002e  f1a00001          SUB      r0,r0,#1              ;75
000032  60a0              STR      r0,[r4,#8]            ;75
000034  68a0              LDR      r0,[r4,#8]            ;76
000036  b910              CBNZ     r0,|L3.62|
000038  f04f0000          MOV      r0,#0                 ;78
00003c  6060              STR      r0,[r4,#4]            ;78
                  |L3.62|
00003e  2001              MOVS     r0,#1                 ;80
000040  e7e6              B        |L3.16|
;;;82     
                          ENDP


                          AREA ||i.EmptyTheQueue||, CODE, READONLY, ALIGN=1

                  EmptyTheQueue PROC
;;;82     
;;;83     void EmptyTheQueue(Queue *pq)
000000  b510              PUSH     {r4,lr}
;;;84     {
000002  f5ad7d02          SUB      sp,sp,#0x208
000006  4604              MOV      r4,r0
;;;85     	Item dummy;
;;;86     	while(!QueueIsEmpty(pq))
000008  e003              B        |L4.18|
                  |L4.10|
;;;87     	{
;;;88     		DeQueue(&dummy,pq);
00000a  4621              MOV      r1,r4
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       DeQueue
                  |L4.18|
000012  4620              MOV      r0,r4                 ;86
000014  f7fffffe          BL       QueueIsEmpty
000018  2800              CMP      r0,#0                 ;86
00001a  d0f6              BEQ      |L4.10|
;;;89     	}
;;;90     }
00001c  f50d7d02          ADD      sp,sp,#0x208
000020  bd10              POP      {r4,pc}
;;;91     
                          ENDP


                          AREA ||i.EnQueue||, CODE, READONLY, ALIGN=2

                  EnQueue PROC
;;;34     
;;;35     bool EnQueue(Item item,Queue *pq)
000000  b40f              PUSH     {r0-r3}
;;;36     {
000002  b530              PUSH     {r4,r5,lr}
000004  b0ff              SUB      sp,sp,#0x1fc
000006  f8dd5410          LDR      r5,[sp,#0x410]
;;;37     	Node *pnew;
;;;38     	if (QueueIsFull(pq))
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       QueueIsFull
000010  b120              CBZ      r0,|L5.28|
;;;39     	{
;;;40     		return FALSE;
000012  2000              MOVS     r0,#0
                  |L5.20|
;;;41     	}
;;;42     	
;;;43     	pnew=(Node *)malloc(sizeof(Node));
;;;44     	if (pnew == NULL)
;;;45     	{
;;;46     		fprintf(stderr,"Unable to allocate memory!\n");
;;;47     		return FALSE;
;;;48     	}
;;;49     	CopyToNode(item,pnew);
;;;50     	pnew->next = NULL;
;;;51     	if (QueueIsEmpty(pq))
;;;52     	{
;;;53     		pq->front = pnew;		//假如队列为空队列，将队列头指针指向新节点
;;;54     	} 
;;;55     	else
;;;56     	{
;;;57     		pq->rear->next = pnew;	//假如队列为非空队列，将新节点添加到队列尾部
;;;58     	}
;;;59     	pq->rear=pnew;				//假如队列为空队列，将队列尾指针指向新节点
;;;60     	pq->items++;
;;;61     	return TRUE;
;;;62     }
000014  b07f              ADD      sp,sp,#0x1fc
000016  bc30              POP      {r4,r5}
000018  f85dfb14          LDR      pc,[sp],#0x14
                  |L5.28|
00001c  f44f7004          MOV      r0,#0x210             ;43
000020  f7fffffe          BL       malloc
000024  4604              MOV      r4,r0                 ;43
000026  b92c              CBNZ     r4,|L5.52|
000028  a112              ADR      r1,|L5.116|
00002a  4819              LDR      r0,|L5.144|
00002c  f7fffffe          BL       __2fprintf
000030  2000              MOVS     r0,#0                 ;47
000032  e7ef              B        |L5.20|
                  |L5.52|
000034  f44f72fc          MOV      r2,#0x1f8             ;49
000038  a986              ADD      r1,sp,#0x218          ;49
00003a  4668              MOV      r0,sp                 ;49
00003c  947e              STR      r4,[sp,#0x1f8]        ;49
00003e  f7fffffe          BL       __aeabi_memcpy4
000042  a882              ADD      r0,sp,#0x208          ;49
000044  c80f              LDM      r0,{r0-r3}            ;49
000046  f7fffffe          BL       CopyToNode
00004a  f04f0000          MOV      r0,#0                 ;50
00004e  f8c40208          STR      r0,[r4,#0x208]        ;50
000052  4628              MOV      r0,r5                 ;51
000054  f7fffffe          BL       QueueIsEmpty
000058  b108              CBZ      r0,|L5.94|
00005a  602c              STR      r4,[r5,#0]            ;53
00005c  e002              B        |L5.100|
                  |L5.94|
00005e  6868              LDR      r0,[r5,#4]            ;57
000060  f8c04208          STR      r4,[r0,#0x208]        ;57
                  |L5.100|
000064  606c              STR      r4,[r5,#4]            ;59
000066  68a8              LDR      r0,[r5,#8]            ;60
000068  f1000001          ADD      r0,r0,#1              ;60
00006c  60a8              STR      r0,[r5,#8]            ;60
00006e  f04f0001          MOV      r0,#1                 ;61
000072  e7cf              B        |L5.20|
;;;63     
                          ENDP

                  |L5.116|
000074  556e6162          DCB      "Unable to allocate memory!\n",0
000078  6c652074
00007c  6f20616c
000080  6c6f6361
000084  7465206d
000088  656d6f72
00008c  79210a00
                  |L5.144|
                          DCD      __stderr

                          AREA ||i.InitializeQueue||, CODE, READONLY, ALIGN=1

                  InitializeQueue PROC
;;;5      
;;;6      void InitializeQueue(Queue *pq)
000000  f04f0100          MOV      r1,#0
;;;7      {
;;;8      	pq->front=pq->rear=NULL;
000004  6041              STR      r1,[r0,#4]
000006  6001              STR      r1,[r0,#0]
;;;9      	pq->items=0;
000008  6081              STR      r1,[r0,#8]
;;;10     }
00000a  4770              BX       lr
;;;11     
                          ENDP


                          AREA ||i.QueueIsEmpty||, CODE, READONLY, ALIGN=1

                  QueueIsEmpty PROC
;;;20     
;;;21     bool QueueIsEmpty(const Queue *pq)
000000  4601              MOV      r1,r0
;;;22     {
;;;23     	if(pq->items == 0)
000002  6888              LDR      r0,[r1,#8]
000004  b908              CBNZ     r0,|L7.10|
;;;24     	{
;;;25     		return TRUE;
000006  2001              MOVS     r0,#1
                  |L7.8|
;;;26     	}
;;;27     	return FALSE;
;;;28     }
000008  4770              BX       lr
                  |L7.10|
00000a  2000              MOVS     r0,#0                 ;27
00000c  e7fc              B        |L7.8|
;;;29     
                          ENDP


                          AREA ||i.QueueIsFull||, CODE, READONLY, ALIGN=1

                  QueueIsFull PROC
;;;11     
;;;12     bool QueueIsFull(const Queue *pq)
000000  4601              MOV      r1,r0
;;;13     {
;;;14     	if(pq->items == MAXQUEUE)
000002  6888              LDR      r0,[r1,#8]
000004  280a              CMP      r0,#0xa
000006  d101              BNE      |L8.12|
;;;15     	{
;;;16     		return TRUE;
000008  2001              MOVS     r0,#1
                  |L8.10|
;;;17     	}
;;;18     	return FALSE;
;;;19     }
00000a  4770              BX       lr
                  |L8.12|
00000c  2000              MOVS     r0,#0                 ;18
00000e  e7fc              B        |L8.10|
;;;20     
                          ENDP


                          AREA ||i.QueueItemCount||, CODE, READONLY, ALIGN=1

                  QueueItemCount PROC
;;;29     
;;;30     int QueueItemCount(const Queue *pq)
000000  4601              MOV      r1,r0
;;;31     {
;;;32     	return (pq->items);
000002  6888              LDR      r0,[r1,#8]
;;;33     }
000004  4770              BX       lr
;;;34     
                          ENDP

